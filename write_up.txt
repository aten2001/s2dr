#S2DR (CS 6238)

**Authors:** Vojtech Miksu, Brian Lebiednik

**Date:** 12/04/2015

```
Our program accomplishes all of the the implementation instructions as described.
```

## Usage

### Prerequisites

- Node.js (4.0+)
- Npm (3.0+)
- OpenSSL (1.0+)
- Any other dependencies can be found in the package.json

### Install

- npm install

## Running

Start server:
```
node(js) server/index
```

Start client app:
```
node(js) client/index
```

## Client Usage

First you will be asked to enter your `USERNAME`. If the `USERNAME` was never used, it creates a new workspace, generates new keys and signs the public key by CA. If the `USERNAME` was already used (the `workspaces/USERNAME` exists), it just tells the program that you want to use this particular workspace.

Then you have to call `init-session HOSTNAME` to start a secure channel.

**Welcome interface:**
```
node(js) client/index
What is your username (workspace)? USERNAME
s2dr:USERNAME> init-session https://localhost:4433
Welcome back USERNAME! Secure channel is ready!
s2dr:USERNAME>
s2dr:USERNAME>
s2dr:USERNAME> help
```

**Common/Required actions for client**
init-session
check-out
check-in
delegate
safe-delete
terminate-session
help

**You can also use normal bash commands** (cwd is set to the selected USERNAME workspace):
```
s2dr:USERNAME> ls
s2dr:USERNAME> touch t1.txt
```

**List all s2dr available commands via:**
```
s2dr:USERNAME> help
```

**Helpful hints for reexecution of the program**
- always delete /server/persist and /server/documents
- execute npm install

## Protocol Details
The program runs an HTTPS server with the Node.js. When the client initiates the session with the server, the server challenges the client with a certificate request during the TLS handshake. Both the client and the server have 4096 bit RSA keys that they request the CA to sign as part of their initialization. The program uses openssl for the key generation and the request for the server to sign the certificate. The certificates are stored locally. After the client have a trusted connection, they share a socket for further communication. This connection is persistent until the client terminates the connection. 
From the socket the client can call all of the required functions. The messages appear to the server with the hostname, socket, and requested action. If the hostname and key of the client do not match during initialization, the server will reject the socket and deny access. The sever knows based off the hostname which active workspace to access as long as the socket is still valid. From this the server can access the active workspace and store or retrieve files for the client.  
The orginal owner or delegated user has several options during the delegation call. The owner is allowed to set the propagtion flag of the file for the other users that the owner delegates access. The owner or delegated user places a max time on the delegation for checking in the algorithm. The communication of the file, client, and permission then are passed to the server. The server checks that file and client exist and that they request is valid. This  
The server checks all request against its access control list for the file requested. The rules for delegation first check the owner of the document and then the delegation rules set on the file by the owner or delegated user. The further algorithm can be found in 'is_allowed.js'. Teh server checks teh permissions of the file to see if the the userid is in them or 'all' then checks if 'check-in', 'check-out', or 'both are present and finally checks the time to ensure that the permission is still valid. 
The program also uses openssl for the encryption and integrity of the the documents. When a user checks in a document, he/she can set the flag on the document to 'CONFIDENTIALITY' and/or 'INTEGRITY' or 'NONE'. When the client sets the flag to 'CONFIDENTIALITY' the server encrypts the file using the openssl library and AES256. When the client sets the 'INTEGRITY' flag, the server captures the SHA256 hash of the file, signs the hash, and stores it. Likewise, it conducts the reverse operations to either decrypt the file or check the integrity of the file to ensure the file has not been modified. 
   

## Security Analysis

### Communication security
The security of the communication between the client and server is based on the security of a 4096 bit RSA key and the use of OpenSSL. OpenSSL conducts the key generation and the encryption, decryption, hashing and signing within the program. The socket communication in the client server commmunication remeains secure with the signing and encrypting of the messages. There are no known attacks to this type of communication that can be accomplished in less than polynomial time. 

### Code security 
Throughout the project, the team checked the code with JSLint. JSLint is a JavaScript program that inspects JavaScript (JSON), returns a message with the approximate location of the source of any problem. JSLint will reject most legal programs as it operates at a higher standard. 

## Contributions
Vojtech Miksu conducted the coding and optimization of the project. His work was instrumental to accomplishing all of the goals set forth in the requirements document. He provided the configurations for the server and client as well as securing the communication between them.

Brian Lebiednik provided code review and documentation. He worked the product to ensure that it accomplished all of the security reviews. He also authored the report for the project and provided proofing.

## Conclusion


